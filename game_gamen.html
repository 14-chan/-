<!DOCTYPE html>
<html>
<head>
    <title>Siebold Cocking</title>
    <style>
        canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
// ã‚²ãƒ¼ãƒ ã®è¨­å®šã¨å¤‰æ•°
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = 800;
canvas.height = 600;

const fruitSymbols = ["ğŸ", "ğŸ", "ğŸŠ", "ğŸ‹", "ğŸŒ"]; // é€²åŒ–æ®µéšã®ã‚·ãƒ³ãƒœãƒ«
const fruitSize = 100; // ãƒ•ãƒ«ãƒ¼ãƒ„ã®ã‚µã‚¤ã‚º
let fruits = []; // è½ã¡ã‚‹ãƒ•ãƒ«ãƒ¼ãƒ„ã‚’æ ¼ç´ã™ã‚‹é…åˆ—
let player = { x: canvas.width / 2, y: canvas.height - 50, width: 100, height: 20 }; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
let gravity = 0.5; // é‡åŠ›
let gameSpeed = 5; // ã‚²ãƒ¼ãƒ ã®é€Ÿåº¦ã€ãƒ•ãƒ«ãƒ¼ãƒ„ã®è½ä¸‹é€Ÿåº¦ã‚’åˆ¶å¾¡

// ãƒ•ãƒ«ãƒ¼ãƒ„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
function Fruit(x, y, symbolIndex) {
    this.x = x;
    this.y = y;
    this.symbolIndex = symbolIndex;
    this.velY = 0;
}

// ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ãƒ•ãƒ«ãƒ¼ãƒ„ã‚’æç”»
Fruit.prototype.draw = function() {
    ctx.font = fruitSize + "px Arial";
    ctx.fillText(fruitSymbols[this.symbolIndex], this.x, this.y);
    this.y += this.velY;
    this.velY += gravity;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è¡çªã‚’ãƒã‚§ãƒƒã‚¯
    if (this.y + fruitSize > player.y && this.x > player.x && this.x < player.x + player.width) {
        this.y = player.y - fruitSize;
        this.velY = 0;
        checkForEvolution(this);
    }

    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®åº•ã‚’ãƒã‚§ãƒƒã‚¯
    if (this.y + fruitSize > canvas.height) {
        this.y = canvas.height - fruitSize;
        this.velY = -this.velY * 0.7; // ãƒã‚¦ãƒ³ãƒ‰åŠ¹æœ
    }
};

// ãƒ•ãƒ«ãƒ¼ãƒ„ã®é€²åŒ–ã‚’ãƒã‚§ãƒƒã‚¯
function checkForEvolution(fruit) {
    fruits.forEach(otherFruit => {
        if (otherFruit !== fruit && otherFruit.x === fruit.x && otherFruit.y === fruit.y) {
            fruit.symbolIndex++;
            fruits.splice(fruits.indexOf(otherFruit), 1); // ä»–ã®ãƒ•ãƒ«ãƒ¼ãƒ„ã‚’å‰Šé™¤
        }
    });

    if (fruit.symbolIndex >= fruitSymbols.length) {
        fruit.symbolIndex = 0; // æœ€å¤§æ®µéšã«é”ã—ãŸã‚‰æœ€åˆã®æ®µéšã«ãƒªã‚»ãƒƒãƒˆ
    }
}

// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æç”»
function drawPlayer() {
    ctx.fillRect(player.x, player.y, player.width, player.height);
}

// ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
function update() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    fruits.forEach(fruit => fruit.draw());
    drawPlayer();
    requestAnimationFrame(update);
}

// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹•ãã‚’åˆ¶å¾¡
document.addEventListener("keydown", function(event) {
    if (event.key === "ArrowLeft") player.x -= gameSpeed;
    if (event.key === "ArrowRight") player.x += gameSpeed;
    if (event.key === "Spacebar" || event.key === " ") {
        fruits.push(new Fruit(Math.random() * canvas.width, 0, Math.floor(Math.random() * fruitSymbols.length)));
    }
});

update(); // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹s
<analysernode src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.14.2/matter.min.js"></script>
// Matter.js ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å–ã‚Šè¾¼ã‚€
const { Engine, Render, World, Bodies, Body, Events } = Matter;

// ã‚¨ãƒ³ã‚¸ãƒ³ã¨ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã‚’ä½œæˆ
const engine = Engine.create();
const render = Render.create({
    element: document.body,
    engine: engine
});

// 2ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¡çªã—ãŸæ™‚ã«å‘¼ã°ã‚Œã‚‹é–¢æ•°
function mergeBodies(pair) {
    const bodyA = pair.bodyA;
    const bodyB = pair.bodyB;

    // æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¨ˆç®—
    const newX = (bodyA.position.x + bodyB.position.x) / 2;
    const newY = (bodyA.position.y + bodyB.position.y) / 2;
    const newRadius = Math.sqrt(bodyA.circleRadius * bodyA.circleRadius + bodyB.circleRadius * bodyB.circleRadius);

    // å¤ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰å‰Šé™¤
    World.remove(engine.world, [bodyA, bodyB]);

    // æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ãƒ¯ãƒ¼ãƒ«ãƒ‰ã«è¿½åŠ 
    const newBody = Bodies.circle(newX, newY, newRadius);
    World.add(engine.world, newBody);
}

// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¡çªã—ãŸæ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
Events.on(engine, 'collisionStart', event => {
    const pairs = event.pairs;
    pairs.forEach(pair => {
        if (pair.bodyA.label === 'fallingObject' && pair.bodyB.label === 'fallingObject') {
            mergeBodies(pair);
        }
    });
});

// ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ãŒæŠ¼ã•ã‚ŒãŸæ™‚ã«æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
window.addEventListener('keydown', event => {
    if (event.code === 'Space') {
        const radius = 30;
        const x = Math.random() * render.options.width;
        const fallingBody = Bodies.circle(x, -radius, radius, { label: 'fallingObject' });
        World.add(engine.world, fallingBody);
    }
});
</script>
</body>
</html>